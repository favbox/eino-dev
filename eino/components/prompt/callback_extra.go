package prompt

import (
	"github.com/favbox/eino/callbacks"
	"github.com/favbox/eino/schema"
)

// CallbackInput 定义了提示词回调的输入参数。
//
// 在提示词组件的 OnStart 回调中，这个结构体将被传递给回调处理器，
// 包含了提示词模板渲染所需的所有信息。
//
// 设计理念：
// 提示词组件作为"数据转换器"，负责将用户的原始输入转换为适合模型的格式。
// CallbackInput 捕获了模板渲染的完整上下文：
//   - 变量数据（Variables）
//   - 模板定义（Templates）
//   - 扩展信息（Extra）
//
// 这种设计体现了提示词组件的核心职责：
//   - 管理提示词模板的生命周期
//   - 处理变量替换和模板渲染
//   - 作为用户输入和模型调用之间的桥梁
//
// 应用场景：
//   - 聊天模板渲染：将用户查询和上下文格式化为对话
//   - 提示词优化：动态调整模板参数
//   - 多模板管理：支持不同场景的提示词切换
//   - A/B 测试：比较不同模板的效果
//
// 最佳实践：
//   - 在 OnStart 回调中记录模板使用情况
//   - 验证变量数据的完整性和有效性
//   - 监控模板渲染的性能和耗时
//   - 记录变量覆盖率（多少变量被实际使用）
type CallbackInput struct {
	// Variables 是提示词模板中使用的变量集合。
	//
	// 包含了模板渲染所需的所有变量，
	// 键为变量名，值为变量的实际内容。
	//
	// 变量类型可以是：
	//   - 字符串：用于文本替换
	//   - 数字：用于计数或条件判断
	//   - 布尔值：用于条件控制
	//   - 对象/数组：用于复杂数据结构
	//
	// 设计原则：
	//   - 变量名应具有描述性（避免单字母缩写）
	//   - 支持嵌套结构（如 user.profile.name）
	//   - 提供默认值以防止模板渲染失败
	//   - 变量值应经过验证和清理
	//
	// 常见变量示例：
	//   - user_query：用户的原始问题
	//   - context：相关的上下文信息
	//   - system_prompt：系统提示词
	//   - current_date：当前日期（动态生成）
	//   - conversation_history：对话历史摘要
	//
	// 变量验证建议：
	//   - 检查必需变量是否缺失
	//   - 验证变量类型是否匹配模板要求
	//   - 清理敏感信息（如 API keys、密码）
	//   - 对长文本进行截断或摘要
	//
	// 性能考虑：
	//   - 避免在变量中存储过大的数据
	//   - 复杂对象应考虑序列化成本
	//   - 共享变量应使用引用避免重复拷贝
	//   - 定期清理不再使用的变量
	//
	// 调试技巧：
	//   - 记录变量总数和大小
	//   - 标记未使用的变量（可能是模板错误）
	//   - 记录变量类型分布
	//   - 监控变量替换的成功率
	Variables map[string]any

	// Templates 是提示词模板的列表。
	//
	// 包含了一个或多个提示词模板定义，
	// 每个模板定义了如何格式化和组织消息。
	//
	// 模板类型：
	//   - 聊天模板：包含系统、用户、助手角色的消息
	//   - 单轮模板：简单的问答格式
	//   - 多轮模板：支持上下文累积的对话格式
	//   - 函数调用模板：用于工具调用的特殊格式
	//
	// 模板管理策略：
	//   - 版本控制：为模板维护版本历史
	//   - A/B 测试：同时测试多个模板版本
	//   - 动态选择：根据场景选择最佳模板
	//   - 回滚机制：快速恢复到稳定版本
	//
	// 模板优化要点：
	//   - 控制模板长度（避免超过模型限制）
	//   - 优化指令清晰度（减少歧义）
	//   - 平衡上下文信息（避免信息过载）
	//   - 支持多语言（国际化需求）
	//
	// 性能影响：
	//   - 模板解析和编译的开销
	//   - 变量替换的计算成本
	//   - 模板缓存的效果
	//   - 多个模板的选择逻辑
	//
	// 最佳实践：
	//   - 为每个模板添加描述和用途说明
	//   - 使用模板变量而非硬编码文本
	//   - 定期评估模板效果并进行优化
	//   - 建立模板质量检查流程
	Templates []schema.MessagesTemplate

	// Extra 是额外的回调信息。
	//
	// 用于传递与提示词组件相关的额外数据，
	// 如：
	//   - 渲染时间戳
	//   - 模板版本信息
	//   - 用户会话标识
	//   - 调用来源标识
	//
	// 这个字段提供了灵活性，
	// 允许在不修改核心结构的情况下添加新信息。
	//
	// 常见用途示例：
	//   - template_version：模板版本号
	//   - render_id：渲染请求唯一标识
	//   - source：调用来源（web/api/batch）
	//   - user_id：用户标识（用于审计）
	//   - session_id：会话标识
	//   - priority：渲染优先级
	//   - timeout_ms：超时时间
	//   - cache_key：缓存键（用于模板缓存）
	//
	// 数据流传递：
	//   - OnStart：Extra 携带初始上下文信息
	//   - OnEnd：Extra 包含渲染结果和统计信息
	//   - 跨组件：Extra 可以传递到下游组件
	//
	// 使用模式：
	//   - 性能监控：记录渲染耗时和资源使用
	//   - 审计追踪：记录模板使用和变量替换
	//   - 调试支持：提供详细的渲染上下文
	//   - 质量保证：验证模板渲染的正确性
	//
	// 最佳实践：
	//   - 使用结构化的键名（如 snake_case）
	//   - 避免在 Extra 中存储大量数据
	//   - 记录 Extra 字段的变更历史
	//   - 为关键 Extra 字段添加验证
	//
	// 注意事项：
	//   - Extra 是 map 类型，需要注意并发安全
	//   - 不同组件间的 Extra 命名应统一
	//   - 敏感信息不应存储在 Extra 中
	//   - 定期清理过期的 Extra 数据
	Extra map[string]any
}

// CallbackOutput 定义了提示词回调的输出结果。
//
// 在提示词组件的 OnEnd 回调中，这个结构体将被传递给回调处理器，
// 包含了提示词模板渲染后的结果和相关信息。
//
// 设计理念：
// CallbackOutput 是提示词组件的"交付物"，它包含了模板渲染的所有产出：
//   - 渲染结果（Result）
//   - 模板信息（Templates）
//   - 扩展信息（Extra）
//
// 这种设计确保了：
//   - 完整的渲染结果被捕获和传递
//   - 模板信息可用于后续分析和优化
//   - 扩展信息支持自定义监控和处理
//
// 监控价值：
//   - 分析模板渲染的效果和质量
//   - 追踪变量替换的完整性和准确性
//   - 监控模板性能指标
//   - 支持模板版本管理和优化
//
// 质量保证：
//   - 验证渲染结果的格式正确性
//   - 检查未替换的变量（模板错误）
//   - 分析渲染输出的长度和结构
//   - 评估模板与模型输入要求的匹配度
type CallbackOutput struct {
	// Result 是提示词模板渲染后的消息结果。
	//
	// 这是提示词组件的核心产出，
	// 包含了根据模板和变量生成的消息列表，
	// 可以直接传递给模型组件使用。
	//
	// 消息结构特征：
	//   - 按模板定义的顺序组织
	//   - 包含系统、用户、助手等角色消息
	//   - 变量已被实际内容替换
	//   - 保持原始的格式和结构
	//
	// 结果验证要点：
	//   - 检查消息列表是否为空
	//   - 验证角色定义是否正确
	//   - 确认变量替换是否完整
	//   - 分析消息总长度（避免超限）
	//
	// 质量评估指标：
	//   - 模板覆盖率：多少模板被实际使用
	//   - 变量填充率：多少变量被成功替换
	//   - 消息完整性：是否包含必要的上下文
	//   - 格式规范性：是否符合模型要求
	//
	// 后续处理流程：
	//   - 直接传递给模型组件
	//   - 存储到对话历史中
	//   - 用于多轮对话的上下文累积
	//   - 作为其他组件的输入
	//
	// 错误处理场景：
	//   - 模板渲染失败（返回错误消息）
	//   - 变量缺失（记录警告并使用默认值）
	//   - 格式错误（返回格式化的错误提示）
	//   - 超长内容（截断并添加标记）
	//
	// 性能分析：
	//   - 记录渲染耗时
	//   - 统计消息数量和总长度
	//   - 分析变量替换效率
	//   - 监控模板缓存命中率
	//
	// 优化机会：
	//   - 识别常用的渲染模式
	//   - 发现未使用的模板变量
	//   - 优化模板结构减少冗余
	//   - 评估模板效果与业务目标
	Result []*schema.Message

	// Templates 是提示词模板的列表（输出副本）。
	//
	// 这个字段包含了用于本次渲染的模板列表，
	//   与输入的 Templates 字段内容相同。
	//
	// 设计目的：
	//   - 记录实际使用的模板（可能经过筛选或修改）
	//   - 支持模板效果的分析和对比
	//   - 提供模板版本的追踪信息
	//   - 便于调试和优化
	//
	// 与输入的区别：
	//   - 输入的 Templates：模板定义（可能包含多个模板）
	//   - 输出的 Templates：实际使用的模板（可能经过选择）
	//
	// 使用场景分析：
	//   - 模板选择记录：哪些模板被选中/跳过
	//   - 模板效果追踪：不同模板的渲染效果对比
	//   - 模板版本管理：记录使用的模板版本
	//   - A/B 测试支持：记录对照组和实验组的模板
	//
	// 模板性能评估：
	//   - 使用频率：每个模板的使用次数
	//   - 渲染速度：不同模板的渲染耗时
	//   - 输出质量：模板产生的结果质量评分
	//   - 错误率：模板渲染失败的频率
	//
	// 优化指导：
	//   - 识别低频使用的模板（考虑移除）
	//   - 发现性能瓶颈模板（进行优化）
	//   - 对比不同版本的效果差异
	//   - 评估模板组合的最佳实践
	//
	// 审计价值：
	//   - 合规要求：记录使用的提示词版本
	//   - 问题排查：回溯特定时期的模板状态
	//   - 知识管理：积累模板使用经验
	//   - 团队协作：共享最佳模板实践
	Templates []schema.MessagesTemplate

	// Extra 是额外的回调输出信息。
	//
	// 用于传递与提示词渲染结果相关的额外数据，
	// 如：
	//   - 渲染耗时统计
	//   - 变量替换统计
	//   - 模板性能指标
	//   - 业务相关标识
	//
	// 这个字段与 CallbackInput.Extra 对应，
	// 允许在回调链路中传递和修改信息。
	//
	// 输出指标示例：
	//   - render_duration_ms：渲染耗时（毫秒）
	//   - template_count：使用的模板数量
	//   - variable_count：变量总数
	//   - variable_filled：成功替换的变量数
	//   - message_count：生成的消息数量
	//   - total_tokens：估算的令牌数
	//
	// 质量指标示例：
	//   - template_hit_rate：模板缓存命中率
	//   - variable_coverage：变量覆盖率（百分比）
	//   - error_count：渲染错误数量
	//   - warning_count：警告数量
	//
	// 性能指标示例：
	//   - render_ops_per_sec：每秒渲染操作数
	//   - avg_template_size：平均模板大小
	//   - cache_efficiency：缓存效率
	//   - memory_usage_mb：内存使用量（MB）
	//
	// 业务指标示例：
	//   - user_satisfaction：用户满意度评分
	//   - conversion_rate：转化率
	//   - engagement_score：参与度评分
	//   - business_value：业务价值评分
	//
	// 数据演化过程：
	//   - 输入：Extra 携带初始上下文信息
	//   - 渲染：回调处理器记录过程数据
	//   - 输出：Extra 包含渲染结果和统计信息
	//   - 传递：Extra 可以传递给下游组件
	//
	// 使用模式：
	//   - 性能监控：跟踪渲染性能趋势
	//   - 质量保证：验证渲染结果质量
	//   - 业务分析：评估模板对业务的影响
	//   - 告警通知：标记异常情况
	//
	// 与 CallbackInput.Extra 的关联：
	//   - 输入 Extra 提供上下文信息
	//   - 输出 Extra 反映处理结果
	//   - 可以对比输入和输出了解处理过程
	//   - 支持增量式的元数据积累
	//
	// 最佳实践：
	//   - 记录关键性能指标
	//   - 添加业务相关的统计信息
	//   - 标记异常和警告情况
	//   - 定期清理历史数据
	Extra map[string]any
}

// ConvCallbackInput 将通用回调输入转换为提示词特定的回调输入。
//
// 这是类型转换函数，用于在回调系统中统一不同来源的输入类型。
//
// 转换逻辑：
//  1. 如果输入已经是 *CallbackInput（组件实现内触发），直接返回
//  2. 如果输入是 map[string]any（图节点注入），包装为 *CallbackInput
//  3. 其他类型返回 nil
//
// 使用场景：
//   - 当回调被图形编排节点注入时
//   - 当在组件内部直接触发回调时
//   - 需要统一处理不同来源的回调输入时
//
// 参数：
//   - src: 通用回调输入（callbacks.CallbackInput）
//
// 返回：
//   - *CallbackInput: 提示词特定的回调输入，或 nil（如果类型不匹配）
//
// 设计理念：
// 提示词组件的输入转换逻辑非常直接，
// 因为提示词组件的核心职责就是处理变量数据。
// ConvCallbackInput 体现了这一设计特点：
//   - map[string]any：直接对应提示词变量集合
//   - *CallbackInput：完整的提示词输入结构
//
// 转换策略详解：
//
//	*CallbackInput → 直接返回：
//	  - 组件内部直接触发的回调
//	  - 已经包含完整的提示词输入信息
//	  - 跳过转换以提高性能
//
//	map[string]any → 轻量级包装：
//	  - 来自图形编排节点的变量注入
//	  - 变量名作为键，变量值作为值
//	  - 包装为完整 CallbackInput 结构
//	  - Templates 字段设为 nil（待后续填充）
//
//	其他类型 → 返回 nil：
//	  - 不支持的输入类型
//	  - 防止意外的类型错误
//	  - 回调处理器应检查返回值
//
// 变量处理流程：
//  1. 接收 map[string]any 类型的变量集合
//  2. 验证变量键名是否符合规范
//  3. 检查变量值的类型和格式
//  4. 包装为 CallbackInput 结构
//  5. 返回供后续处理使用
//
// 变量验证建议：
//   - 检查变量名是否为空或重复
//   - 验证变量值的合法性
//   - 清理敏感信息
//   - 记录未识别的变量
//
// 错误处理模式：
//   - 空 map：返回警告但继续处理
//   - 变量数量过多：记录性能警告
//   - 异常数据类型：记录错误并尝试转换
//   - nil 输入：返回 nil 或默认结构
//
// 性能考虑：
//   - 直接返回的场景零拷贝转换
//   - 包装场景创建轻量级结构
//   - 避免深拷贝，引用原 map 数据
//   - 变量验证不应过于复杂
//
// 最佳实践：
//   - 在包装前验证变量数据的有效性
//   - 为缺失的关键变量提供默认值
//   - 记录变量数量和类型分布
//   - 考虑变量缓存以提高性能
//
// 示例：
//
//	// 在组件实现内
//	input := &prompt.CallbackInput{Variables: vars}
//	converted := prompt.ConvCallbackInput(input)
//	// converted == input
//
//	// 在图形节点中
//	input := map[string]any{"query": "hello", "context": "..."}
//	converted := prompt.ConvCallbackInput(input)
//	// converted 是新的 *CallbackInput，Variables 字段被设置
func ConvCallbackInput(src callbacks.CallbackInput) *CallbackInput {
	switch t := src.(type) {
	case *CallbackInput:
		return t
	case map[string]any:
		return &CallbackInput{
			Variables: t,
		}
	default:
		return nil
	}
}

// ConvCallbackOutput 将通用回调输出转换为提示词特定的回调输出。
//
// 这是类型转换函数，用于在回调系统中统一不同来源的输出类型。
//
// 转换逻辑：
//  1. 如果输出已经是 *CallbackOutput（组件实现内触发），直接返回
//  2. 如果输出是 []*schema.Message（图节点注入），包装为 *CallbackOutput
//  3. 其他类型返回 nil
//
// 使用场景：
//   - 当回调被图形编排节点注入时
//   - 当在组件内部直接触发回调时
//   - 需要统一处理不同来源的回调输出时
//
// 参数：
//   - src: 通用回调输出（callbacks.CallbackOutput）
//
// 返回：
//   - *CallbackOutput: 提示词特定的回调输出，或 nil（如果类型不匹配）
//
// 设计理念：
// 提示词组件的输出转换遵循相同的简洁原则。
// ConvCallbackOutput 旨在统一不同来源的输出格式：
//   - 直接输出：完整的 CallbackOutput（包含 Result、Templates、Extra）
//   - 图形注入：简单的 []*schema.Message（模板渲染后的消息列表）
//
// 此转换函数的价值：
//   - 保持接口的一致性
//   - 支持灵活的组件组合
//   - 简化下游组件的处理逻辑
//   - 提供渐进式的能力增强
//
// 转换策略详解：
//
//	*CallbackOutput → 直接返回：
//	  - 组件内部直接返回的完整输出
//	  - 包含所有详细的渲染信息
//	  - 保持数据的完整性和准确性
//
//	[]*schema.Message → 轻量级包装：
//	  - 来自图形编排节点的标准输出
//	  - 代表模板渲染后的消息结果
//	  - 动态补充默认模板和统计信息
//
//	其他类型 → 返回 nil：
//	  - 不支持的输出格式
//	  - 触发错误处理或降级逻辑
//	  - 防止类型错误传播
//
// 动态补充机制：
// 当包装 []*schema.Message 为 *CallbackOutput 时：
//   - Result：使用传入的消息列表
//   - Templates：设为 nil（未知模板定义）
//   - Extra：设为 nil（无额外信息）
//
// 这种设计允许：
//   - 快速原型开发和测试
//   - 简化简单场景的使用
//   - 逐步添加更多功能
//   - 向下兼容不同版本
//
// 消息处理流程：
//  1. 接收 []*schema.Message 类型的渲染结果
//  2. 验证消息列表的格式和完整性
//  3. 检查消息角色和内容是否正确
//  4. 包装为 CallbackOutput 结构
//  5. 返回供下游组件使用
//
// 质量检查要点：
//   - 验证消息列表不为空
//   - 检查角色定义的规范性
//   - 确认消息内容的完整性
//   - 评估消息长度是否合适
//
// 性能特性：
//   - 零拷贝转换（直接返回场景）
//   - 最小内存分配（包装场景）
//   - 浅拷贝引用，共享底层数据
//   - 避免不必要的序列化/反序列化
//
// 最佳实践建议：
//   - 在需要完整信息的场景，直接返回 *CallbackOutput
//   - 在快速集成场景，可以使用 []*schema.Message
//   - 定期审计 nil 字段的频率和原因
//   - 考虑为包装后的输出补充更多信息
//
// 示例：
//
//	// 在组件实现内
//	output := &prompt.CallbackOutput{Result: msgs}
//	converted := prompt.ConvCallbackOutput(output)
//	// converted == output
//
//	// 在图形节点中
//	output := []*schema.Message{...}
//	converted := prompt.ConvCallbackOutput(output)
//	// converted 是新的 *CallbackOutput，Result 字段被设置
func ConvCallbackOutput(src callbacks.CallbackOutput) *CallbackOutput {
	switch t := src.(type) {
	case *CallbackOutput:
		return t
	case []*schema.Message:
		return &CallbackOutput{
			Result: t,
		}
	default:
		return nil
	}
}
