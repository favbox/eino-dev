# Deep Agent 设计架构分析文档

**文档版本**：v1.0
**最后更新**：2025年
**作者**：基于代码深度分析

---

## 概述

Deep Agent 是 Eino 框架中一个**预构建的高级智能体实现**，采用分层架构和中间件模式设计。它构建在 ADK（Agent Development Kit）框架之上，提供强大的任务委派和智能编排能力。

Deep Agent 的核心思想是**将复杂任务分解为独立的子任务，并通过 `task` 工具委派给专门的子智能体并行处理**，最后整合结果返回给用户。这种"分而治之"的哲学使其特别适合处理需要多步骤、可并行、上下文密集的复杂任务。

## 整体架构

```
Deep Agent (adk/prebuilt/deep/)
├── 核心层 (deep.go)          - 配置、初始化、主入口
├── 工具层 (task_tool.go)     - 子智能体编排与任务委派
├── 提示层 (prompt.go)        - 多模板提示词系统
└── 类型层 (types.go)         - 常量和类型定义
```

---

## 一、核心设计思想

### 1. 任务分解与委派模式

Deep Agent 的核心理念是将复杂任务分解为可并行处理的独立子任务。

**工作机制**：
- 主智能体接收用户请求后，分析并识别可以独立执行的子任务
- 通过内置的 `task` 工具，动态创建子智能体来处理特定任务
- 每个子智能体拥有独立的上下文窗口，避免信息交叉污染
- 子智能体完成任务后返回综合结果，主智能体负责整合生成最终答案

**设计优势**：
- ✅ **上下文隔离**：每个子智能体专注于特定任务，避免上下文混淆
- ✅ **并行处理**：多个独立任务可同时执行，提高效率和响应速度
- ✅ **Token 优化**：每个子智能体只关注相关主题，避免浪费 token
- ✅ **责任分离**：主智能体专注任务编排和结果整合，子智能体专注具体执行

### 2. 内置任务管理

Deep Agent 集成 `write_todos` 工具，帮助智能体主动管理复杂任务的执行状态。

**核心功能**：
- 跟踪任务状态（`pending`/`in_progress`/`completed`）
- 提供任务规划和进度可视化能力
- 指导智能体何时应该使用或避免使用任务列表

**使用原则**：
- 建议用于：复杂多步骤任务（3步以上）、需要规划的非平凡任务
- 不宜用于：简单1-2步任务、纯粹对话或信息查询

---

## 二、核心组件分析

### 1. Deep Agent 主入口（deep.go）

**配置驱动设计**：

```go
type Config struct {
    Name        string                    // 智能体标识
    Description string                    // 功能说明
    ChatModel   model.ToolCallingChatModel // 聊天模型
    Instruction string                    // 系统指令
    SubAgents   []adk.Agent               // 子智能体列表
    ToolsConfig adk.ToolsConfig           // 工具配置
    MaxIteration int                      // 最大迭代次数

    // 可选功能开关
    WithoutWriteTodos       bool  // 禁用待办事项工具
    WithoutGeneralSubAgent  bool  // 禁用通用子智能体
}
```

**关键特性**：
- **自动构建中间件**：根据配置构建内置的 `write_todos` 工具中间件
- **创建 task tool**：初始化子智能体编排器，将所有子智能体封装为工具
- **返回执行引擎**：使用 `adk.NewChatModelAgent` 创建最终的智能体实例

**构建流程**：
```
New() → buildBuiltinAgentMiddlewares() → newTaskToolMiddleware()
       ↓
adk.NewChatModelAgent() → 返回完整的智能体实例
```

### 2. Task Tool 子智能体编排器（task_tool.go）

**设计模式**：**工具封装 + 动态路由**

```go
type taskTool struct {
    subAgents     map[string]tool.InvokableTool  // 子智能体映射表
    subAgentSlice []adk.Agent                    // 子智能体列表（用于描述生成）
    descGen       func(ctx, agents) (string, error) // 描述生成器
}
```

**核心功能**：

1. **子智能体注册**
    - 将所有传入的 `SubAgents` 封装为可调用工具
    - 创建通用子智能体（general-purpose agent，如未禁用）
    - 构建名称到工具的映射表，支持快速路由

2. **动态描述生成**
    - 根据可用子智能体动态生成 task 工具的描述文本
    - 包含每个子智能体的能力说明和使用场景
    - 使主智能体能理解何时以及如何调用子智能体

3. **智能路由**
    - 接收 `subagent_type` 和 `description` 参数
    - 根据 `subagent_type` 查找对应的子智能体
    - 将任务描述传递给子智能体执行

4. **通用子智能体**
    - 可选的 `general-purpose` 子智能体
    - 拥有与主智能体相同的能力（相同的模型、工具、指令）
    - 适用于需要隔离上下文但不需要特殊能力的通用任务

**工作流程**：
```
1. 初始化 → newTaskTool()
   ├─ 创建 taskTool 实例
   ├─ 配置描述生成器（默认或自定义）
   ├─ 构建通用子智能体（如未禁用）
   └─ 注册所有子智能体到映射表

2. 调用执行 → InvokableRun()
   ├─ 解析输入参数（subagent_type + description）
   ├─ 查找对应的子智能体
   ├─ 调用子智能体的 InvokableRun()
   └─ 返回子智能体的结果

3. 描述生成 → Info()
   ├─ 调用描述生成器函数
   ├─ 包含所有可用子智能体的说明
   └─ 返回完整的工具描述
```

### 3. 提示词系统（prompt.go）

**多模板架构**：

- **`writeTodosPrompt`**（约40行）：待办事项工具使用指南
    - 包含何时使用/不使用该工具的决策指南
    - 5+个实际示例展示正确使用场景

- **`taskPrompt`**（约70行）：任务委派工具使用指南
    - 详细说明子智能体的生命周期（Spawn → Run → Return → Reconcile）
    - 7+个示例覆盖不同类型的任务场景

-  **`baseAgentPrompt`**  ：基础智能体提示词
- **工具描述模板**：详细的 JSON 格式描述

**设计亮点**：
- ✅ **示例驱动**：每个提示词包含丰富的使用示例
- ✅ **决策指南**：明确说明何时使用或不使用特定工具
- ✅ **最佳实践**：包含详细的注意事项和使用规范
- ✅ **格式清晰**：使用 Markdown 格式，易于阅读和理解

---

## 三、架构设计模式

### 1. 中间件模式（Middleware Pattern）

```go
// 构建中间件链
middlewares := []adk.AgentMiddleware{
    {AdditionalInstruction: baseAgentPrompt},
    writeTodosMiddleware,   // 内置：任务管理
    taskToolMiddleware,     // 内置：子智能体编排
}
```

**实现原理**：
- 使用 ADK 的 `AgentMiddleware` 机制扩展智能体功能
- 每个中间件可以添加额外的系统指令和工具
- 中间件按顺序执行，形成处理管道

**优势**：
- 功能模块化，易于扩展和维护
- 支持灵活的功能组合（可选择性禁用某些功能）
- 符合开闭原则（对扩展开放，对修改关闭）

### 2. 工具封装模式（Tool Wrapper Pattern）

```go
// 将智能体封装为工具
agentTool := adk.NewAgentTool(ctx, subAgent)
invokableTool := assertAgentTool(agentTool)
```

**实现原理**：
- 任何实现 `adk.Agent` 接口的智能体都可被封装
- 通过 `adk.AgentTool` 适配器转换为标准工具接口
- 封装后可通过工具的 `InvokableRun()` 方法调用

**优势**：
- 统一的调用方式，无论调用普通工具还是智能体
- 支持智能体嵌套，构建层次化的多智能体系统
- 与编排框架无缝集成

### 3. 配置与构建分离（Separation of Config and Build）

**设计**：
- `Config` 结构体：纯数据对象，封装所有配置参数
- `New()` 函数：负责构建和初始化逻辑
- 清晰的职责分离

**优势**：
- 配置可序列化，支持持久化和传输
- 构建逻辑集中管理，便于测试和调试
- 遵循单一职责原则（SRP）

---

## 四、工作流程详解

### 场景示例：用户请求"研究三位篮球巨星的成就并比较"

```
┌─────────────────────────────────────────────────────────────┐
│ 用户：研究勒布朗·詹姆斯、迈克尔·乔丹和科比·布莱恩特的成就并比较 │
└─────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────┐
│ 步骤 1：主智能体接收并分析                                   │
│ - 识别出 3 个独立的研究任务                                  │
│ - 判断可并行执行                                             │
└─────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────┐
│ 步骤 2：调用 task 工具（并行执行）                           │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ task(subagent_type="general-purpose",                   │ │
│ │       description="研究勒布朗·詹姆斯的成就")              │ │
│ │                                                         │ │
│ │ task(subagent_type="general-purpose",                   │ │
│ │       description="研究迈克尔·乔丹的成就")              │ │
│ │                                                         │ │
│ │ task(subagent_type="general-purpose",                   │ │
│ │       description="研究科比·布莱恩特的成就")            │ │
│ └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────┐
│ 步骤 3：各子智能体独立执行                                   │
│ - 每个子智能体拥有自己的上下文窗口                           │
│ - 深入研究和分析，可能调用搜索、分析等工具                   │
│ - 返回综合结果（而非所有中间步骤）                           │
└─────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────┐
│ 步骤 4：主智能体整合结果                                     │
│ - 接收三个子智能体的报告                                     │
│ - 进行综合比较分析                                           │
│ - 生成最终答案返回用户                                       │
└─────────────────────────────────────────────────────────────┘
```

### 架构优势分析

| 优势维度 | 具体表现 |
|---------|---------|
| **Token 效率** | 每个子智能体只关注一个主题，避免上下文膨胀 |
| **执行效率** | 三个研究任务并行执行，大幅缩短总耗时 |
| **上下文质量** | 子智能体专注单一主题，避免信息交叉污染 |
| **分析深度** | 每个子智能体可以深入使用工具和资源 |
| **结果质量** | 主智能体在综合报告基础上进行高层次比较 |

---

## 五、适用场景分析

### ✅ 适合使用 Deep Agent 的场景

#### 1. 复杂多步骤任务
- **示例**：市场调研、代码库安全审计、竞品分析
- **特征**：需要 5+ 步骤，涉及多个工具和操作

#### 2. 可并行独立子任务
- **示例**：多主题研究、批量数据处理、多文件分析
- **特征**：子任务之间无依赖，可独立执行

#### 3. 需要上下文隔离
- **示例**：大型代码库分析、多领域混合研究
- **特征**：不同部分适合不同的上下文管理策略

### ❌ 不适合使用 Deep Agent 的场景

#### 1. 简单 1-2 步任务
- **示例**：查询天气、简单计算、快速信息查询
- **原因**：创建子智能体的开销大于收益

#### 2. 需要查看中间步骤
- **示例**：调试、教学、需要解释推理过程
- **原因**：task 工具隐藏了子智能体的中间步骤

#### 3. 强依赖顺序的任务
- **示例**：前一步输出是后一步输入
- **原因**：并行执行不适用，需要串行编排

### 选择决策树

```
任务是否足够复杂（5+ 步骤或涉及多个工具）？
├── 否 → 直接使用普通 Agent
│
└── 是 → 子任务是否可并行？
    ├── 是 → ✅ 使用 Deep Agent
    │         └─ 可获得：并行处理 + 上下文隔离
    │
    └── 否 → 任务是否需要上下文隔离？
        ├── 是 → ✅ 使用 Deep Agent（串行调用 task）
        │     └─ 可获得：上下文管理 + 专注执行
        │
        └── 否 → 使用 Plan-Execute 或 Supervisor 模式
```

---

## 六、与 ADK 框架的关系

### Deep Agent 在 ADK 生态中的定位

```
┌─────────────────────────────────────────┐
│          ADK 应用层                      │
├─────────────────────────────────────────┤
│  Deep Agent (任务委派与编排)              │
│  ┌───────────────────────────────────┐ │
│  │ buildBuiltinAgentMiddlewares()    │ │
│  │ newTaskToolMiddleware()           │ │
│  │ newWriteTodos()                   │ │
│  └───────────────────────────────────┘ │
├─────────────────────────────────────────┤
│          ADK 核心层                      │
│  ├─ ChatModelAgent (基础智能体)        │
│  └─ AgentMiddleware (中间件机制)       │
├─────────────────────────────────────────┤
│          组件抽象层                      │
│  ├─ model.ToolCallingChatModel       │
│  └─ tool.BaseTool                     │
└─────────────────────────────────────────┘
```

### Deep Agent 如何利用 ADK

1. **基础执行引擎**
    - 使用 `adk.ChatModelAgent` 作为底层智能体实现
    - 继承其流式处理、错误处理、迭代控制等能力

2. **中间件扩展机制**
    - 利用 ADK 的 `AgentMiddleware` 添加功能
    - `AdditionalInstruction`：添加系统级指令
    - `AdditionalTools`：注入内置工具（task、write_todos）

3. **工具封装能力**
    - 通过 `adk.NewAgentTool()` 将智能体转换为工具
    - 支持智能体之间的嵌套和组合
    - 统一了工具和智能体的调用接口

4. **继承核心能力**
    - ✅ 流式处理（Stream/Invoke）
    - ✅ 回调机制（Callbacks）
    - ✅ 错误处理与重试
    - ✅ Tool Calling 支持

### 延伸生态

Deep Agent 还可以与 Eino 的其他组件集成：
- **compose.Graph**：构建更复杂的工作流
- **flow.retriever**：集成检索能力
- **components.document**：处理文档输入
- **callbacks.Handler**：添加监控和日志

---

## 七、设计哲学总结

### 核心原则：分而治之（Divide and Conquer）

Deep Agent 的设计哲学体现在四个层次：

#### 1. 任务分解（Decomposition）
- **识别可并行性**：自动分析任务结构，识别独立子任务
- **边界清晰**：每个子任务有明确的输入、输出和职责
- **降低复杂度**：将大问题分解为可管理的小问题

#### 2. 智能委派（Delegation）
- **路由选择**：通过 `task` 工具将任务路由到合适的子智能体
- **能力匹配**：子智能体的能力与任务需求相匹配
- **沙箱隔离**：每个子智能体在独立的上下文中执行

#### 3. 结果合成（Synthesis）
- **信息整合**：主智能体整合多个子智能体的输出
- **层次提升**：从具体结果中提取更高层次的洞察
- **最终交付**：生成对用户有价值的综合答案

#### 4. 过程管理（Orchestration）
- **进度跟踪**：通过 `write_todos` 管理复杂任务状态
- **并行协调**：同时管理多个子智能体的执行
- **错误处理**：优雅处理子智能体失败或异常情况

### 架构价值

| 维度 | 传统 Agent | Deep Agent |
|-----|-----------|-----------|
| **单任务吞吐量** | 中等 | ✅ 高（并行处理） |
| **Token 使用效率** | 低（上下文膨胀） | ✅ 高（上下文隔离） |
| **复杂任务能力** | 有限（容易分心） | ✅ 强（专注执行） |
| **结果质量** | 一般（广度优先） | ✅ 优秀（深度+广度） |
| **可扩展性** | 困难 | ✅ 简单（添加子智能体） |

### 适用团队建议

| 团队规模 | 推荐模式 | 原因 |
|---------|---------|------|
| 初级团队 | Host-Specialist（简单版 Deep Agent） | 实现简单，学习曲线平缓 |
| 中级团队 | Deep Agent（完整版） | 平衡复杂度与性能 |
| 高级团队 | Deep Agent + 自定义编排 | 充分利用灵活性与扩展性 |

---

## 八、最佳实践

### 1. 子智能体设计原则

✅ **应该**：
- 为子智能体提供清晰的名称和描述
- 根据任务类型设计专门的子智能体（如 research-analyst、code-reviewer）
- 保持子智能体的关注点单一
- 为通用任务保留 general-purpose 子智能体

❌ **不应该**：
- 创建过于通用的子智能体（失去分工价值）
- 让子智能体处理不相关的多种任务
- 在子智能体中包含主智能体的逻辑

### 2. Task 工具使用策略

✅ **应该**：
- 将完全独立的任务委派给 task 工具
- 使用并行调用处理多个独立子任务
- 为子智能体提供清晰、详细的任务描述
- 在需要深度分析时使用 task 工具隔离上下文

❌ **不应该**：
- 使用 task 工具处理简单 1-2 步任务
- 在子任务间有强依赖时强行并行
- 期望看到子智能体的中间步骤（task 工具隐藏了这些）

### 3. 与 write_todos 配合

✅ **应该**：
- 对 5+ 步骤的复杂任务使用 write_todos
- 实时更新任务状态（完成后立即标记）
- 在发现新信息时调整待办事项列表
- 为新发现的依赖创建新的待办事项

❌ **不应该**：
- 对简单任务使用 write_todos（浪费 token）
- 批量标记多个任务完成（影响透明度）
- 创建过于笼统的待办事项（应具体可执行）

---

## 九、潜在扩展方向

### 1. 智能任务路由优化

**可能改进**：
- 增加子智能体能力评分机制
- 实现基于历史表现的动态路由
- 添加任务复杂度评估自动决定是否使用 task 工具

**技术方案**：
```go
type SubAgentCapability struct {
    Name        string
    Description string
    Score       float64  // 历史成功率
    AvgTokens   int      // 平均 token 使用
    AvgDuration time.Duration  // 平均执行时间
}
```

### 2. 结果质量控制

**可能改进**：
- 添加子智能体结果置信度评估
- 实现多子智能体结果交叉验证
- 自动重试失败的子任务

### 3. 任务依赖图支持

**可能改进**：
- 支持定义子任务间的依赖关系
- 实现基于 DAG 的任务调度
- 动态调整执行顺序以优化效率

---

## 十、总结

Deep Agent 是 Eino 框架中一个**优雅的任务委派与编排实现**，通过"分而治之"的哲学有效解决了复杂任务处理的挑战。

### 核心优势

1. **清晰的架构分层**：配置、工具、提示词、类型各司其职
2. **灵活的中间件机制**：易于扩展和功能组合
3. **智能的任务委派**：动态路由 + 上下文隔离
4. **完善的提示词系统**：示例驱动，决策清晰
5. **优秀的工程实践**：类型安全、错误处理、测试覆盖

### 核心价值

Deep Agent 的核心价值在于**在保持高质量输出的同时，优化 token 使用和执行效率**。它特别适合处理需要多步骤、可并行、上下文密集的复杂任务，是构建高级多智能体应用的理想选择。

### 获取源码

Deep Agent 实现位于：`adk/prebuilt/deep/`
查看源码深入理解：https://github.com/cloudwego/eino/tree/main/adk/prebuilt/deep

---

**文档结束**